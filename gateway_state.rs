// auto-generated by notebook
use std::sync::{Arc, RwLock};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ChaosConfig {
    #[serde(flatten)]
    pub flags: HashMap<String, serde_json::Value>,
}
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RlWeights {
    #[serde(flatten)]
    pub weights: HashMap<String, f64>,
}
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TenantConfig {
    #[serde(default)]
    pub chaos: ChaosConfig,
    #[serde(default)]
    pub rl_weights: RlWeights,
    #[serde(default)]
    pub ratelimits: Option<serde_json::Value>,
}
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct GatewayControlPlane {
    pub ts: u64,
    pub schema: String,
    #[serde(default)]
    pub chaos: ChaosConfig,
    #[serde(default)]
    pub rl_weights: RlWeights,
    #[serde(default)]
    pub tenants: HashMap<String, TenantConfig>,
    #[serde(default)]
    pub _meta: Option<serde_json::Value>,
}
#[derive(Clone)]
pub struct AppState {
    inner: Arc<RwLock<GatewayControlPlane>>,
    pub admin_token: Option<String>,
}
impl AppState {
    pub fn new(initial: GatewayControlPlane, admin_token: Option<String>) -> Self {
        Self {
            inner: Arc::new(RwLock::new(initial)),
            admin_token,
        }
    }
    pub fn read(&self) -> GatewayControlPlane {
        self.inner.read().unwrap().clone()
    }
    pub fn update(&self, new_val: GatewayControlPlane) {
        *self.inner.write().unwrap() = new_val;
    }
    pub fn check_admin(&self, tok: Option<&str>) -> bool {
        match (&self.admin_token, tok) {
            (Some(required), Some(got)) => got == required,
            (Some(_), None) => false,
            (None, _) => true,
        }
    }
    pub fn merge_effective_chaos(&self, ns: Option<&str>) -> ChaosConfig {
        let s = self.inner.read().unwrap();
        let mut out = s.chaos.clone();
        if let Some(ns) = ns {
            if let Some(tcfg) = s.tenants.get(ns) {
                for (k, v) in &tcfg.chaos.flags {
                    out.flags.insert(k.clone(), v.clone());
                }
            }
        }
        out
    }
    pub fn merge_effective_rl(&self, ns: Option<&str>) -> RlWeights {
        let s = self.inner.read().unwrap();
        let mut out = s.rl_weights.clone();
        if let Some(ns) = ns {
            if let Some(tcfg) = s.tenants.get(ns) {
                for (k, v) in &tcfg.rl_weights.weights {
                    out.weights.insert(k.clone(), *v);
                }
            }
        }
        out
    }
}
