// auto-generated by notebook
use axum::{extract::State, Json, http::StatusCode, response::IntoResponse};
use serde_json::json;
use crate::gateway_state::{AppState, GatewayControlPlane, ChaosConfig, RlWeights};
fn admin_token_from_header(headers: &axum::http::HeaderMap) -> Option<String> {
    headers
        .get("x-admin-token")
        .and_then(|v| v.to_str().ok())
        .map(|s| s.to_string())
}
pub async fn get_chaos(
    State(app): State<AppState>,
    headers: axum::http::HeaderMap,
) -> impl IntoResponse {
    if !app.check_admin(admin_token_from_header(&headers).as_deref()) {
        return (StatusCode::UNAUTHORIZED, Json(json!({"error":"unauthorized"})));
    }
    let cur = app.read();
    (StatusCode::OK, Json(json!({ "chaos": cur.chaos.flags })))
}
#[derive(Debug, serde::Deserialize)]
pub struct ChaosPayload {
    #[serde(flatten)]
    pub flags: serde_json::Map<String, serde_json::Value>,
    #[serde(default)]
    pub ns: Option<String>,
}
pub async fn set_chaos(
    State(app): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(payload): Json<ChaosPayload>,
) -> impl IntoResponse {
    if !app.check_admin(admin_token_from_header(&headers).as_deref()) {
        return (StatusCode::UNAUTHORIZED, Json(json!({"error":"unauthorized"})));
    }
    let mut cur = app.read();
    if let Some(ns) = &payload.ns {
        if let Some(tcfg) = cur.tenants.get_mut(ns) {
            for (k, v) in payload.flags.iter() {
                tcfg.chaos.flags.insert(k.clone(), v.clone());
            }
        } else {
            // create tenant on the fly
            use std::collections::HashMap;
            let mut tcfg = crate::gateway_state::TenantConfig::default();
            for (k, v) in payload.flags.iter() {
                tcfg.chaos.flags.insert(k.clone(), v.clone());
            }
            cur.tenants.insert(ns.clone(), tcfg);
        }
    } else {
        for (k, v) in payload.flags.iter() {
            cur.chaos.flags.insert(k.clone(), v.clone());
        }
    }
    app.update(cur.clone());
    (StatusCode::OK, Json(json!({"ok": true, "chaos": cur.chaos.flags})))
}
#[derive(Debug, serde::Deserialize)]
pub struct RlPayload {
    pub weights: serde_json::Map<String, serde_json::Value>,
    #[serde(default)]
    pub ns: Option<String>,
}
pub async fn rl_update(
    State(app): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(payload): Json<RlPayload>,
) -> impl IntoResponse {
    if !app.check_admin(admin_token_from_header(&headers).as_deref()) {
        return (StatusCode::UNAUTHORIZED, Json(json!({"error":"unauthorized"})));
    }
    let mut cur = app.read();
    if let Some(ns) = &payload.ns {
        if let Some(tcfg) = cur.tenants.get_mut(ns) {
            for (k, v) in payload.weights.iter() {
                if let Some(num) = v.as_f64() {
                    tcfg.rl_weights.weights.insert(k.clone(), num);
                }
            }
        }
    } else {
        for (k, v) in payload.weights.iter() {
            if let Some(num) = v.as_f64() {
                cur.rl_weights.weights.insert(k.clone(), num);
            }
        }
    }
    app.update(cur.clone());
    (StatusCode::OK, Json(json!({"ok": true})))
}
pub async fn get_config(State(app): State<AppState>) -> impl IntoResponse {
    let cur = app.read();
    (StatusCode::OK, Json(cur))
}
